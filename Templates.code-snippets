{
	// Place your CodeForces workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }


	/****************************** Starting Template for any program *********************************/


	"Initial Basic Template": {
		"prefix": "load",
		"body": [
		  "#include <bits/stdc++.h>",
		  "",
		  "using namespace std;",
		  "",
		  "#define mod 1000000007 ",
		  "#define set(n) cout << fixed << setprecision(n)    ",
		  "#define fi first",
		  "#define se second",
		  "#define mp make_pair",
		  "#define pll pair<lli, lli>",
		  "#define endl '\\n'",
		  "",
		  "const double PI = acos(-1);",
		  "const double epsilon = 1e-7;  // floating point precision",
		  "",
		  "typedef long long int lli;",
		  "typedef long double ld;",
		  "",
		  "signed main(void) {",
		  "    ios_base::sync_with_stdio(false);",
		  "    cin.tie(NULL);",
		  "}",
		  "",
		],
		"description": "Initial Basic Template"
	},


	/****************************** Function To find All prime numbers less than n *********************************/


	"Sieve": {
		"prefix": "Sieve",
		"body": [
		  "vector<lli> primes;",
		  "vector<lli> sieve(lli n){ // find all prime numbers <= n",
		  "    vector<bool> v(n + 1, false);",
		  "    v[2] = true;",
		  "    for(int i = 3; i <= n; i += 2) v[i] = true;",
		  "    for(size_t i = 3; i <= n; i += 2){",
		  "        if(v[i]){",
		  "            for(size_t j = i * i; j <= n; j += 2 * i){",
		  "                v[j] = false;",
		  "            }",
		  "        }",
		  "    }",
		  "    v[1] = v[0] = false;",
		  "    for(int i = 0; i < v.size(); i++) if(v[i]) primes.push_back(i);",
		  "    return primes;",
		  "}"
		],
		"description": "Sieve"
	  },


	  /****************************** Function To find all prime factors of a number *********************************/


	  "Prime Factors Of a Number": {
		"prefix": "PrimeFactors",
		"body": [
		  "vector<lli> primes;",
		  "vector<lli> sieve(lli n){ // find all prime numbers <= n",
		  "    vector<bool> v(n + 1, false);",
		  "    v[2] = true;",
		  "    for(int i = 3; i <= n; i += 2) v[i] = true;",
		  "    for(size_t i = 3; i <= n; i += 2){",
		  "        if(v[i]){",
		  "            for(size_t j = i * i; j <= n; j += 2 * i){",
		  "                v[j] = false;",
		  "            }",
		  "        }",
		  "    }",
		  "    v[1] = v[0] = false;",
		  "    for(int i = 0; i < v.size(); i++) if(v[i]) primes.push_back(i);",
		  "    return primes;",
		  "}",
		  "vector<pll> primeFactors(lli n){ // returns all prime factors with along with their powers",
		  "    lli p = primes[0]; vector<pll> f; int i = 0;",
		  "    while(i < primes.size() && p * p <= n){",
		  "        lli count = 0;",
		  "        while(p > 0 and n % p == 0){",
		  "            count++; n /= p;",
		  "        }",
		  "        if(count > 0) f.push_back(mp(p, count));",
		  "        i++;",
		  "        if(i == primes.size()) break;",
		  "        p = primes[i];",
		  "    }",
		  "    if(n > 1){ // number is itself prime",
		  "        f.push_back(mp(n, 1));",
		  "    }",
		  "    return f;",
		  "}"
		],
		"description": "Prime Factors Of a Number"
	  },
	  
	 
	  /****************************** Function to find All factors of a number *********************************/


	  "All Factors Of A Number": {
		"prefix": "AllFactors",
		"body": [
		  "vector<lli> factors(lli n){ // returns all factors of a given number",
		  "    lli lim = sqrt(n);  vector<lli> f;",
		  "    for(int i = 1; i <= lim; i++){",
		  "        if(n % i == 0){",
		  "            f.push_back(i), f.push_back(n / i);",
		  "            if(i*i == n) f.pop_back();",
		  "        }",
		  "    }",
		  "    return f;",
		  "}"
		],
		"description": "All Factors Of A Number"
	  },


	  /****************************** Function For Modular Exponentiation *********************************/


	  "Power And Mod Inverse": {
		"prefix": "Power",
		"body": [
		  "lli power(lli b, lli p, lli m = mod){",
		  "    lli res = 1;",
		  "    while(p > 0){",
		  "        if(p & 1)",
		  "            res = ((res % m) * (b % m)) % m;",
		  "        b = ((b % m) * (b % m)) % m; p = p>>1;",
		  "    }",
		  "    return res;",
		  "}",
		  "lli modInverse(lli n, lli m = mod){ return power(n, m - 2, m);}"
		],
		"description": "Power And Mod Inverse"
	  },


	  /****************************** User Defined GCD AND LCM *********************************/


	  "GCD And LCM": {
		"prefix": "GCDLCM",
		"body": [
		  "lli gcd(lli a, lli b){",
		  "    while(b > 0){",
		  "        lli r = a % b; a = b; b = r;",
		  "    }",
		  "    return a;",
		  "}",
		  "",
		  "lli lcm(lli a, lli b){",
		  "    return (a * b) / gcd(a, b);",
		  "}",
		  ""
		],
		"description": "GCD And LCM"
	  },


	  /****************************** Pair Class Hash For Collison Handling *********************************/


	  "Custom Pair Class Hash": {
		"prefix": "MyHash",
		"body": [
		  "struct myHash { // collision handling comparator for pair class",
		  "    template <class T1, class T2>",
		  "    size_t operator()(const pair<T1, T2>& p) const{ ",
		  "        auto hash1 = hash<T1>{}(p.first), hash2 = hash<T2>{}(p.second); ",
		  "        return hash1 ^ hash2; ",
		  "    } ",
		  "}; "
		],
		"description": "Custom Pair Class Hash"
	  },

	  /****************************** Ordered Set Template *********************************/


	  "Ordered Set": {
		"prefix": "OrderedSet",
		"body": [
		  "#include <ext/pb_ds/assoc_container.hpp> ",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "using namespace __gnu_pbds;",
		  "",
		  "template <class T>",
		  "using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;  // ordered set",
		  ""
		],
		"description": "Ordered Set"
	  },


	  /****************************** Simple Debugger *********************************/
	  
	 
	  "Debugger": {
		"prefix": "Debug",
		"body": [
		  "#define debug(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args);}",
		  "void err(istream_iterator<string> it) {}",
		  "template<class T, class... Args>",
		  "void err(istream_iterator<string> it, T a, Args... args) { cerr << *it << \" = \" << a << endl; err(++it, args...); }"
		],
		"description": "Debugger"
	  },


	  /****************************** Variadic Argument Min Max *********************************/


	  "Multiple Argument Max and Min": {
		"prefix": "MultiMaxMin",
		"body": [
		  "#define __max(args...) __Max(args)   // Multiple Argument max, default type is the first argument type",
		  "template<class T>",
		  "T __Max() {return (T)LLONG_MIN;}",
		  "template <class T, class... Args>",
		  "T __Max(T a, Args... args) {return max(a, __Max<T>(args...));}",
		  "",
		  "#define __min(args...) __Min(args)  // Multiple Argument min, default type is the first argument type",
		  "template<class T>",
		  "T __Min() {return (T)LLONG_MAX;}",
		  "template <class T, class... Args>",
		  "T __Min(T a, Args... args) {return min(a, __Min<T>(args...));}"
		],
		"description": "Multiple Argument Max and Min"
	  },

	  /****************************** Pair Sort Function *********************************/

	  "Custom Sorting Function": {
		"prefix": "MySort",
		"body": [
		  "bool mySort(pair<int, int> p1, pair<int, int> p2) { ",
		  "    if(p1.fi - p1.se < p2.fi - p2.se) return true;",
		  "    else if(p1.fi - p1.se == p2.fi - p2.se and p1.se > p2.se) return true;",
		  "    return false;",
		  "}"
		],
		"description": "Custom Sorting Function"
	  },

	  /****************************** User Defined Ceil *********************************/

	  "Precise Ceil Function": {
		"prefix": "Ceil",
		"body": [
		  "inline lli ceilAB(lli a, lli b){ return (a + b - 1) / b;}"
		],
		"description": "Precise Ceil Function"
	  },



	  /****************************** Disjoint Set Union *********************************/


	  "Disjoint Set Union": {
		"prefix": "DSU",
		"body": [
		  "class DSU {",
		  "private :",
		  "    vector<lli> set;",
		  "public :",
		  "    DSU(int n){",
		  "        set.assign(n, -1);",
		  "    }",
		  "    int size(int i){",
		  "        i = parent(i);",
		  "        return -set[i];",
		  "    }",
		  "    int parent(int i){    // find parent and path compression",
		  "        if(set[i] <= -1){",
		  "            return i;",
		  "        }",
		  "        set[i] = parent(set[i]);",
		  "        return set[i];",
		  "    }",
		  "    void Union(int i, int j){",
		  "        i = parent(i);",
		  "        j = parent(j);",
		  "        if(i == j){",
		  "            return;",
		  "        }",
		  "        set[j] = i;",
		  "    }",
		  "    lli getDistinct(){",
		  "        lli ct = 0;",
		  "        for(int i = 0; i < set.size(); i++){",
		  "            if(set[i] < 0) ct++;",
		  "        }",
		  "        return ct;",
		  "    }",
		  "};",
		  ""
		],
		"description": "Disjoint Set Union"
	  },

	  
	  /************************* Graph Data Structure And Algorithms ***********************************/


	  /****************************** Simple Graph Class *********************************/

	  "Very Basic Graph ": {
		"prefix": "Graph",
		"body": [
		  "template <class T>",
		  "class Graph {",
		  "public :",
		  "    int N;",
		  "    vector<vector<lli>> g;   // adjacency list ",
		  "    map<pll, T> W;         // weights",
		  "    Graph(lli n) {    // zero indexed vertices",
		  "        N = n;",
		  "        g.assign(N, vector<lli>());",
		  "        W.clear();      ",
		  "    }",
		  "    void refresh() {",
		  "        // customize before use",
		  "    }",
		  "    void add(lli u, lli v, T w) {",
		  "        g[u].push_back(v);",
		  "        W[{u, v}] = w;",
		  "    }",
		  "    T getWeight(lli u, lli v) {",
		  "        return W[{u,v}];",
		  "    }",
		  "    vector<lli> & operator[](lli u){",
		  "        return g[u];",
		  "    }",
		  "};"
		],
		"description": "Very Basic Graph "
	  },

	  /****************************** Graph Class for important algorithms *********************************/

	  "Basic Graph ": {
		"prefix": "Graph-Alpha",
		"body": [
		  "template <class T>",
		  "class Graph {",
		  "public : ",
		  "    int N;",
		  "    vector<vector<lli>> g;   // adjacency list ",
		  "    map<pll, T> W;         // weights",
		  "    vector<lli> par;         // parent relation",
		  "    vector<lli> dep;         // depth in DFS",
		  "    vector<lli> sz;          // size of component rooted at vertex",
		  "    vector<lli> in;          // in time",
		  "    vector<lli> out;         // out time",
		  "    vector<bool> visited;    // required for DFS/BFS",
		  "    vector<lli> low;",
		  "    lli t;",
		  "    Graph(lli n) {    // zero indexed vertices",
		  "        N = n;",
		  "        g.assign(N, vector<lli>());",
		  "        W.clear();  par.assign(N, -1);",
		  "        dep.assign(N, 0); sz.assign(N, 0);",
		  "        in.assign(N, 0); out.assign(N, 0);",
		  "        visited.assign(N, false); low.assign(N, 0);",
		  "        t = 0;",
		  "    }",
		  "    void refresh() {",
		  "        // customize before use",
		  "    }",
		  "    void add(lli u, lli v, T w) {",
		  "        g[u].push_back(v);",
		  "        W[{u, v}] = w;",
		  "    }",
		  "    T getWeight(lli u, lli v) {",
		  "        return W[{u,v}];",
		  "    }",
		  "    vector<lli> & operator[](lli u){",
		  "        return g[u];",
		  "    }",
		  "};"
		],
		"description": "Basic Graph "
	  },


	  /****************************** Basic DFS Algorithm *********************************/


	  "Basic Graph DFS": {
		"prefix": "Graph-DFS",
		"body": [
		  "void DFS(lli u){            // Basic DFS",
		  "        visited[u] = true;",
		  "        in[u] = t++; sz[u] = 1;",
		  "        for(auto v : g[u]){",
		  "            if(!visited[v]){",
		  "                par[v] = u, dep[v] = dep[u] + 1;",
		  "                DFS(v);",
		  "                sz[u] += sz[v];",
		  "            }",
		  "        }",
		  "        out[u] = t++;",
		  "    }"
		],
		"description": "Basic Graph DFS"
	  },


	  /****************************** Basic BFS Algorithm *********************************/


	  "Basic Graph BFS": {
		"prefix": "Graph-BFS",
		"body": [
		  "void BFS(lli u){           // Basic BFS",
		  "        visited[u] = true;",
		  "        queue<lli> q;",
		  "        q.push(u);",
		  "        while(!q.empty()){",
		  "            lli curr = q.front();",
		  "            q.pop();",
		  "            for(auto v : g[curr]){",
		  "                if(!visited[v]){",
		  "                    par[v] = par[curr], dep[v] = dep[curr] + 1;",
		  "                    q.push(v);",
		  "                }",
		  "            }",
		  "        }",
		  "    }"
		],
		"description": "Basic Graph BFS"
	  },

	  /****************************** Spanning Tree Algorithm *********************************/

	  "Min/Max Spanning Tree": {
		"prefix": "Graph-MST",
		"body": [
		  "void MST(){               // Finds Minimum Spanning tree, can be converted easily to Maximum Spanning Tree  ",
		  "        vector<lli> tree;",
		  "        vector<lli> d(N, INT_MAX);   // maximum need be changed as per requirement",
		  "        d[0] = 0;",
		  "        set<pll> s;",
		  "        for(int i = 0; i < N; i++){",
		  "            if(i == 0)",
		  "                s.insert({0, 0});",
		  "            else ",
		  "                s.insert({INT_MAX, i});",
		  "        }",
		  "        while(!s.empty()){",
		  "            lli u = s.begin()->se;",
		  "            tree.push_back(d[u]);",
		  "            s.erase(s.begin());",
		  "            for(auto v : g[u]){",
		  "                if(d[v] > W[{u, v}]){",
		  "                    s.erase({d[v], v});",
		  "                    d[v] = W[{u, v}];",
		  "                    s.insert({d[v], v});",
		  "                }",
		  "            }",
		  "        }",
		  "        lli mst = 0;",
		  "        for(int i = 1; i < tree.size(); i++) mst += tree[i];   // not considering the first one which is zero",
		  "    }"
		],
		"description": "Min/Max Spanning Tree"
	  },


	/****************************** Shortest Path Algorithm - Dijkstra And Floyd Warshall *********************************/


	  "Shortest Path Algorithms": {
		"prefix": "Graph-SP",
		"body": [
		  "vector<lli> SSSP(lli u){       //  Single Source Shortest Path from u to every other vertex, works if there are no negative weight cycles",
		  "                            // Works efficiently for all edges positive in weight",
		  "        vector<lli> d(N, INT_MAX);   // maximum need be changed as per requirement",
		  "        d[u] = 0;",
		  "        set<pll> s;",
		  "        par.assign(N, -1);",
		  "        lli ct = 0;",
		  "        for(int i = 0; i < N; i++){",
		  "            if(i == u)",
		  "                s.insert({0, i});",
		  "            else ",
		  "                s.insert({INT_MAX, i});",
		  "        }",
		  "        while(!s.empty()){",
		  "            lli curr = s.begin()->second;",
		  "            s.erase(s.begin());",
		  "            for(auto v : g[curr]) {",
		  "                if(d[v] > d[curr] + W[{curr, v}]) {      // possible to relax edge",
		  "                    if(s.find({d[v], v}) != s.end()){",
		  "                        s.erase({d[v], v});",
		  "                    }",
		  "                    par[v] = curr;           // parent of v is curr",
		  "                    d[v] = d[curr] + W[{curr, v}];",
		  "                    s.insert({d[v], v});",
		  "                    ct++;",
		  "                }  ",
		  "            }",
		  "        }",
		  "        // d contains all the single sources shortest path distances, and par contains the parent pointers",
		  "        // for(int i = 0; i <  N; i++) {",
		  "        //     cout<<\"Shortest Path from \"<<u + 1<<\" to \"<<i + 1<<\" is \"<<d[i]<<endl;",
		  "        // }",
		  "        //cout<<ct<<endl;",
		  "        return d;",
		  "    }",
		  "",
		  "    void APSP(){        // Finds All Pair Shortest Paths",
		  "        vector<vector<lli>> dp(N, vector<lli>(N, INT_MAX));     // max can be changed",
		  "        vector<vector<lli>> par(N, vector<lli>(N, -1));         // maintain parent links",
		  "        for(auto edge : W){",
		  "            dp[edge.fi.fi][edge.fi.se] = edge.se; ",
		  "            par[edge.fi.fi][edge.fi.se] = edge.fi.fi;",
		  "        }",
		  "        for(int i = 0; i < N; i++) dp[i][i] = 0;      // Shortest Distance of every vertex to itself is 0",
		  "        for(int k = 0; k < N; k++){",
		  "            for(int i = 0; i < N; i++){",
		  "                for(int j = 0; j < N; j++){",
		  "                    if(dp[i][k] == INT_MAX or dp[k][j] == INT_MAX) continue;",
		  "                    if(dp[i][j] > dp[i][k] + dp[k][j]){",
		  "                        dp[i][j] = dp[i][k] + dp[k][j];",
		  "                        par[i][j] = par[k][j];     // parent of j in shortest path from i = parent of j in shortest path from k",
		  "                    }",
		  "                }",
		  "            }",
		  "        }",
		  "        // dp contains All Pair Shortest Paths for (i, j)",
		  "        // for(int i = 0; i < N; i++) {",
		  "        //     for(int j = 0; j < N; j++) {",
		  "        //         cout<<\"Shortest path from \"<<i + 1<<\" to \"<<j + 1<<\" is \"<<dp[i][j]<<'\\n';",
		  "        //     }",
		  "        // }",
		  "    }"
		],
		"description": "Shortest Path Algorithms"
	  },


	  /****************************** Cut Vertices And Bridges using Tarjan's Algorithm *********************************/


	  "Cut Vertex And Bridges": {
		"prefix": "Graph-Cut",
		"body": [
		  "    void CutVertexAndBridges(lli u, vector<lli> & low, vector<bool> & cv, map<pll, bool> & br){",
		  "        visited[u] = true;",
		  "        in[u] = t++;",
		  "        low[u] = in[u];",
		  "        lli ct = 0;",
		  "        for(auto v : g[u]){",
		  "            if(!visited[v]){",
		  "                CutVertexAndBridges(v, low, cv, br);",
		  "                low[u] = min(low[u], low[v]);",
		  "                if(low[v] >= in[u] and u > 0){             // We have found a bridge and cut vertex",
		  "                    cv[u] = true;",
		  "                    br[{u,v}] = true;",
		  "                }",
		  "                ++ct;",
		  "            }",
		  "            else {",
		  "                low[u] = min(low[u], in[v]);     // Back Edge",
		  "            }",
		  "        }",
		  "        if(u == 0 and ct > 1) {",
		  "            cv[u] = true;",
		  "            for(auto v : g[u]) {",
		  "                br[{u, v}] = true;",
		  "            }",
		  "        } ",
		  "    }",
		  "",
		  "    vector<bool> CutVertexAndBridges() {",
		  "        visited.assign(N, false); in.assign(N, 0); par.assign(N, -1); low.assign(N, 0); t = 0;",
		  "        vector<bool> cv(N);          // stores the cut vertices of the graph",
		  "        map<pll, bool> br;          // stores the bridges of the graph",
		  "        CutVertexAndBridges(0, low, cv, br);",
		  "        return cv;",
		  "    }"
		],
		"description": "Cut Vertex And Bridges"
	  },


	  /****************************** Strong Connected Component Algorithm *********************************/


	  "Strong Connected Components": {
		"prefix": "Graph-SCC",
		"body": [
		  "    void SCC_T(lli u, stack<lli>& S, vector<lli>& component) {",
		  "        visited[u] = true;",
		  "        in[u] = ++t;",
		  "        low[u] = in[u];",
		  "        S.push(u);",
		  "        for(auto v : g[u]) {",
		  "            if(!visited[v]) {",
		  "                SCC_T(v, S, component);",
		  "                low[u] = min(low[u], low[v]);",
		  "            }",
		  "            else if(component[v] == -1) {",
		  "                low[u] = min(low[u], in[v]);",
		  "            }",
		  "        }",
		  "        if(low[u] == in[u]) {  // found root of sink",
		  "            while(S.top() != u) {",
		  "                component[S.top()] = u;",
		  "                S.pop();",
		  "            }",
		  "            S.pop(); component[u] = u;",
		  "        }",
		  "        out[u] = ++t;",
		  "    }",
		  "",
		  "    void SCC_T() {",
		  "        vector<lli> component(N, -1); visited.assign(N, false); low.assign(N, 0), in.assign(N, 0);",
		  "        stack<lli> S;",
		  "        for(int i = 0; i < N; i++) {",
		  "            if(!visited[i]) {",
		  "                SCC_T(i, S, component);",
		  "            }",
		  "        }",
		  "        vector<vector<lli>> components(N);",
		  "        for(int i = 0; i < N; i++) {",
		  "            components[component[i]].push_back(i);",
		  "        }",
		  "        // for(int i = 0; i < N; i++) {",
		  "        //     if(components[i].size() > 0) {",
		  "        //         cout<<\"The component rooted at vertex \"<<i + 1<<\" is \"<<endl;",
		  "        //         for(auto u : components[i]) cout<<u + 1<<endl;",
		  "        //     }",
		  "        // }",
		  "    }"
		],
		"description": "Strong Connected Components"
	  },


	  /****************************** Some Algorithms For Directed Acyclic Graphs *********************************/


	  "DAG Algorithms": {
		"prefix": "Graph-DAG",
		"body": [
		  "vector<lli> TopSort(){          ",
		  "        queue<lli> q;",
		  "        vector<lli> deg(N);           // stores the indegree of vertices",
		  "        for(int i = 0; i < N; i++){",
		  "            for(auto v : g[i]){",
		  "                deg[v]++;            // increment the indegree",
		  "            }",
		  "        }",
		  "        for(int i = 0; i < N; i++){",
		  "            if(deg[i] == 0) q.push(i);        // push all vertices with indegree 0",
		  "        }",
		  "        vector<lli> topSort;",
		  "        while(!q.empty()){",
		  "            lli curr = q.front();",
		  "            topSort.push_back(curr);",
		  "            q.pop();",
		  "            for(auto v : g[curr]){",
		  "                deg[v]--;",
		  "                if(deg[v] == 0) q.push(v);",
		  "            }",
		  "        }",
		  "        // topSort contains the topological sorting",
		  "        return topSort;",
		  "    }",
		  "",
		  "    void DAG_SSSP(lli u) {",
		  "        auto topSort = TopSort();",
		  "        int index;",
		  "        for(int i = 0; i < N; i++) {",
		  "            if(topSort[i] == u) {",
		  "                index = i;",
		  "            }",
		  "        }",
		  "        vector<lli> dp(N, INT_MAX);",
		  "        dp[u] = 0;",
		  "        for(int i = index; i < topSort.size(); i++) {",
		  "            int idx = topSort[i];",
		  "            for(auto v : g[idx]) {",
		  "                if(dp[v] > dp[idx] + W[{idx, v}]) {",
		  "                    dp[v] = dp[idx] + W[{idx, v}];",
		  "                }",
		  "            }",
		  "        }",
		  "        // for(int i = 0; i < N; i++){",
		  "        //     if(dp[i] != INT_MAX){",
		  "        //         cout<<\"The minimum distance of vertex \"<<i + 1<<\" from \"<<u + 1<<\" is \"<<dp[i]<<endl;",
		  "        //     }",
		  "        // }",
		  "    }"
		],
		"description": "DAG Algorithms"
	  },


	  /****************************** Finding Bi-Connected Components *********************************/


	  "Bi Connected Components": {
		"prefix": "Graph-BCC",
		"body": [
		  "    void BiConnected(){",
		  "        visited.assign(N, false); par.assign(N, -1); low.assign(N, 0); in.assign(N, 0);",
		  "        stack<pll> currComp;   // Stores the current 2 connected component",
		  "        vector<vector<pll>> components;   // Will Store the edges in the ith Block",
		  "        int cnt = 0;",
		  "        components.assign(N, vector<pll>());",
		  "        while(!currComp.empty())       // Emptying the stack before use",
		  "            currComp.pop();",
		  "        for(int i = 0; i < N; i++){",
		  "            if(!visited[i]) {  // if vertex is not visited start a new component",
		  "                t = 0;",
		  "                BiConnected(i, currComp, components, cnt);",
		  "                bool flag = false;",
		  "                while(!currComp.empty()){         // If the stack is not empty we have a new Bi-Component",
		  "                    flag = true;",
		  "                    components[cnt].push_back(currComp.top());",
		  "                    currComp.pop();",
		  "                }",
		  "                if(flag) ",
		  "                    cnt++;",
		  "            }",
		  "        }",
		  "        // for(int i = 0; i < components.size(); i++){         // Printing the Components",
		  "        //     if(components[i].size() == 0) continue;",
		  "        //     cout<<\"Bi-Component \"<<i + 1<<\" has : \";",
		  "        //     for(int j = 0; j < components[i].size(); j++){",
		  "        //         cout<<components[i][j].first + 1<<\" \"<<components[i][j].second + 1 <<\"  \";",
		  "        //     }",
		  "        //     cout<<'\\n';",
		  "        // }",
		  "    }",
		  "",
		  "    void BiConnected(lli u, stack<pll>& currComp, vector<vector<pll>>& components, int& cnt) {",
		  "        visited[u] = true; // mark vertex as visited",
		  "        in[u] = t++; low[u] = in[u];",
		  "        int ct = 0;                         // finds the number of children of the vertex in the DFS tree",
		  "        for(lli v : g[u]){",
		  "            if(!visited[v]) {",
		  "                currComp.push({u, v});    //  pushing the edge as part of the component",
		  "                par[v] = u;                // setting the parent relation",
		  "                BiConnected(v, currComp, components, cnt);            // recursive call to find BiConnected Component for vertex v",
		  "                ct++;",
		  "                low[u] = min(low[u], low[v]);",
		  "                // Condition To Check if the given vertex is a cut vertex for the component we have found",
		  "                if((in[u] == 0 and ct > 1) or (in[u] > 0 and low[v] >= in[u])){          ",
		  "                    while(currComp.top() != make_pair(u, v)) {    // while we do not reach the pushed edge",
		  "                        components[cnt].push_back(currComp.top()); currComp.pop();",
		  "                    }",
		  "                    components[cnt].push_back(currComp.top());   // pushing the edge u,v",
		  "                    currComp.pop(); cnt++;",
		  "                }",
		  "            }",
		  "            else {",
		  "                low[u] = min(low[u], in[v]);",
		  "                if(v != par[u]){                 // If This edge is not already pushed during call to vertex u",
		  "                    if(in[v] < in[u])            // If we have a back edge push into the component",
		  "                        currComp.push({u, v});",
		  "                }",
		  "            }",
		  "        }",
		  "    }"
		],
		"description": "Bi Connected Components"
	  },

	  /****************************** Algorithm To find Tree Centre And Diameter *********************************/

	  "Tree Centre And Diameter": {
		"prefix": "Tree-Diam",
		"body": [
		  "vector<lli> findDiameter(lli & diam) {  // returns the vertices at the centre and the value of the diamter",
		  "        queue<lli> q;",
		  "        set<lli> s;",
		  "        diam = 0;",
		  "        vector<lli> inDeg(N), centre;",
		  "        for(int i = 0; i < N; i++) {",
		  "            s.insert(i);",
		  "            inDeg[i] = g[i].size();",
		  "            if(inDeg[i] <= 1) q.push(i);",
		  "        }",
		  "        while(s.size() > 2) {",
		  "            queue<lli> temp;",
		  "            while(!q.empty()) {",
		  "                lli curr = q.front();",
		  "                q.pop();",
		  "                s.erase(curr);",
		  "                for(auto v : g[curr]) {",
		  "                    inDeg[v]--;",
		  "                    if(inDeg[v] == 1) temp.push(v);",
		  "                }",
		  "            }",
		  "            q = temp;",
		  "            diam += 2; ",
		  "        }",
		  "        diam += s.size() - 1;",
		  "        for(auto e : s) centre.push_back(e);",
		  "        return centre;",
		  "    }"
		],
		"description": "Tree Centre And Diameter"
	  },


	   /****************************** Template to find Least Common Ancestor in Tree *********************************/


	  "Least Common Ancestor for Tree Template": {
		"prefix": "Graph-LCA",
		"body": [
		  "    vector<vector<lli>> up; lli l;",
		  "    void lca_dfs(lli u, vector<vector<lli>>& up, const lli& l) {",
		  "        in[u] = t++;",
		  "        up[u][0] = par[u];",
		  "        for(int i = 1; i <= l; i++) {",
		  "            up[u][i] = up[up[u][i - 1]][i - 1];",
		  "        }",
		  "        for(auto v : g[u]) {",
		  "            if(v != par[u]) {",
		  "                par[v] = u;",
		  "                lca_dfs(v, up, l);",
		  "            }",
		  "        }",
		  "        out[u] = t++;",
		  "    }",
		  "",
		  "    void lca_set() {",
		  "        par.assign(N, 0); in.assign(N, 0); out.assign(N, 0); t = 0;",
		  "        l = ceil(log2(N));",
		  "        up.assign(N + 1, vector<lli>(l + 1));",
		  "        lca_dfs(0, up, l);",
		  "    }",
		  "",
		  "    bool isAncestor(lli u, lli v) {",
		  "        return in[u] <= in[v] and out[u] >= out[v];",
		  "    }",
		  "",
		  "    lli lca(lli u, lli v) {",
		  "        if(isAncestor(u, v)) return u;",
		  "        if(isAncestor(v, u)) return v;",
		  "        for(int i = l; i >= 0; i--) {",
		  "            if(!isAncestor(up[u][i], v)) {",
		  "                u = up[u][i];",
		  "            }",
		  "        }",
		  "        return up[u][0];",
		  "    }"
		],
		"description": "Least Common Ancestor for Tree Template"
	},

	/****************************** Algorithm To Compress Directed Graph into DAG of its Strong Components *********************************/

	"Directed Graph to DAG And SCC": {
		"prefix": "Graph-DAG+SCC",
		"body": [
		  "void kosaraju_dfs(lli u, stack<lli>& s) {  // obtain a post order",
		  "    visited[u] = true;",
		  "    for(auto v : g[u]) {",
		  "        if(!visited[v]) {",
		  "            kosaraju_dfs(v, s);",
		  "        }",
		  "    }",
		  "    s.push(u);",
		  "}",
		  "void kosaraju_scc(lli u, lli r, vector<lli>& color) {   // assign colors",
		  "    color[u] = r;",
		  "    visited[u] = true;",
		  "    for(auto v : g[u]) {",
		  "        if(!visited[v]) {",
		  "            kosaraju_scc(v, r, color);",
		  "        }",
		  "    }",
		  "}",
		  "pair<Graph<lli>, vector<vector<lli>>> convertToDAG() {   // Finds the Strong Components and compresses them to a DAG",
		  "    vector<vector<T>> revG(N);  // reverse adjacency list",
		  "    stack<lli> s; visited.assign(N, false);",
		  "    for(int u = 0; u < N; u++) {",
		  "        for(auto v : g[u]) {",
		  "            revG[v].push_back(u);",
		  "        }",
		  "    }",
		  "    swap(g, revG);",
		  "    for(int u = 0; u < N; u++) {",
		  "        if(!visited[u]) {",
		  "            kosaraju_dfs(u, s);",
		  "        }",
		  "    }",
		  "    swap(revG, g); visited.assign(N, false);",
		  "    vector<lli> color(N);",
		  "    lli c = 0;",
		  "    while(!s.empty()) {",
		  "        lli u = s.top(); s.pop();",
		  "        if(!visited[u]) {",
		  "            kosaraju_scc(u, c, color);",
		  "            c++;",
		  "        }",
		  "    }",
		  "    set<pll> joined;  // stores the edges between strong components",
		  "    Graph<lli> dag(c);",
		  "    vector<vector<lli>> bags(c);",
		  "    for(int u = 0; u < N; u++) {",
		  "        bags[color[u]].push_back(u);",
		  "        for(auto v : g[u]) {",
		  "            if(color[v] != color[u]) {",
		  "                if(joined.find({color[u], color[v]}) == joined.end()) {",
		  "                    joined.insert({color[u], color[v]});",
		  "                    dag.add(color[u], color[v], 0);",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "    return {dag, bags};    ",
		  "}"
		],
		"description": "Directed Graph to DAG And SCC"
	},

	//   "Segment Tree Template": {
	// 	"prefix": "segTree",
	// 	"body": [
	// 	  "class segTree {",
	// 	  "    public :",
	// 	  "    class node {",
	// 	  "        public :",
	// 	  "        node() {",
	// 	  "            // initailize with neutral values",
	// 	  "        }",
	// 	  "        node(lli init) {  // initialize for lazy",
	// 	  "            // min = init;",
	// 	  "        }",
	// 	  "    };",
	// 	  "    lli n;",
	// 	  "    vector<node> tree;",
	// 	  "    vector<lli> a;",
	// 	  "    vector<bool> mark;",
	// 	  "    vector<node> lazy;",
	// 	  "    segTree(vector<lli>& v) {",
	// 	  "        n = v.size();",
	// 	  "        a = v;",
	// 	  "        tree.resize(4*n + 1);",
	// 	  "        mark.resize(4*n + 1);",
	// 	  "        lazy.resize(4*n + 1 /*Initialize Lazy*/);",
	// 	  "    }",
	// 	  "    node query(lli l, lli r) {",
	// 	  "        return query(1, 0, n - 1, l, r);",
	// 	  "    }",
	// 	  "    void update(lli l, lli r, lli change) {",
	// 	  "        update(1, 0, n - 1, l, r, change);",
	// 	  "    }",
	// 	  "    void build() {",
	// 	  "        build(1, 0, n - 1);",
	// 	  "    }",
	// 	  "    private :",
	// 	  "    void buildLeaf(lli index, lli start) {",
	// 	  "        // set leaf",
	// 	  "    }",
	// 	  "    void updateNode(lli index, lli change) {",
	// 	  "        // update node and lazy",
	// 	  "    }",
	// 	  "    node combine(node& one, node& two) {",
	// 	  "        // combine recursive results and return",
	// 	  "    }",
	// 	  "    void push(lli index) {",
	// 	  "        if(mark[index]) {",
	// 	  "            lli left = index << 1, right = left | 1;",
	// 	  "            // updateNode(left, lazy[index].min), updateNode(right, lazy[index].min);",
	// 	  "            mark[left] = mark[right] = true;",
	// 	  "            //   modify lazy			",
	// 	  "            mark[index] = false;",
	// 	  "        }",
	// 	  "    }",
	// 	  "    void update(lli index, lli start, lli end, lli l, lli r, lli change) {",
	// 	  "        if(l > end or r < start) return;",
	// 	  "        if(l <= start and r >= end) {",
	// 	  "            updateNode(index, change);",
	// 	  "            mark[index] = true;",
	// 	  "            return;",
	// 	  "        }",
	// 	  "        if(start == end) return;",
	// 	  "        push(index);",
	// 	  "        lli mid = (start + end) >> 1;",
	// 	  "        lli left = index << 1, right = left | 1;",
	// 	  "        update(left, start, mid, l, r, change), update(right, mid + 1, end, l, r, change);",
	// 	  "        tree[index] = combine(tree[left], tree[right]);",
	// 	  "    }",
	// 	  "    node query(lli index, lli start, lli end, lli l, lli r) {",
	// 	  "        if(l > end or r < start) {",
	// 	  "            return node();",
	// 	  "        }",
	// 	  "        if(l <= start and r >= end) {",
	// 	  "            return tree[index];",
	// 	  "        }",
	// 	  "        push(index);",
	// 	  "        lli mid = (start + end) >> 1;",
	// 	  "        lli left = index << 1, right = left | 1;",
	// 	  "        auto one = query(left, start, mid, l, r), two = query(right, mid + 1, end, l, r);",
	// 	  "        return combine(one, two);",
	// 	  "    }",
	// 	  "    void build(lli index, lli start, lli end) {",
	// 	  "        if(start == end) {",
	// 	  "            buildLeaf(index, start);",
	// 	  "            return;",
	// 	  "        }",
	// 	  "        lli mid = (start + end) >> 1;",
	// 	  "        lli left = index << 1, right = left | 1;",
	// 	  "        build(left, start, mid), build(right, mid + 1, end);",
	// 	  "        tree[index] = combine(tree[left], tree[right]);",
	// 	  "    }",
	// 	  "}; "
	// 	],
	// 	"description": "Segment Tree Template"
	//   },
	//   "Segment Tree Range Minimum": {
	// 	"prefix": "segTree-Min",
	// 	"body": [
	// 	  "class segTree {",
	// 	  "    public :",
	// 	  "    class node {",
	// 	  "        public :",
	// 	  "        lli min;",
	// 	  "        node() {",
	// 	  "            // initailize with neutral values",
	// 	  "            min = LLONG_MAX;",
	// 	  "        }",
	// 	  "        node(lli init) {  // initialize for lazy",
	// 	  "            min = init;",
	// 	  "        }",
	// 	  "    };",
	// 	  "    lli n;",
	// 	  "    vector<node> tree;",
	// 	  "    vector<lli> a;",
	// 	  "    vector<bool> mark;",
	// 	  "    vector<node> lazy;",
	// 	  "    segTree(vector<lli>& v) {",
	// 	  "        n = v.size();",
	// 	  "        a = v;",
	// 	  "        tree.resize(4*n + 1);",
	// 	  "        mark.resize(4*n + 1);",
	// 	  "        lazy.assign(4*n + 1, node(0));",
	// 	  "    }",
	// 	  "    node query(lli l, lli r) {",
	// 	  "        return query(1, 0, n - 1, l, r);",
	// 	  "    }",
	// 	  "    void update(lli l, lli r, lli change) {",
	// 	  "        update(1, 0, n - 1, l, r, change);",
	// 	  "    }",
	// 	  "    void build() {",
	// 	  "        build(1, 0, n - 1);",
	// 	  "    }",
	// 	  "    private :",
	// 	  "    void buildLeaf(lli index, lli start) {",
	// 	  "        // set leaf",
	// 	  "        tree[index].min = a[start];",
	// 	  "    }",
	// 	  "    void updateNode(lli index, lli change) {",
	// 	  "        // update node and lazy",
	// 	  "        tree[index].min += change;",
	// 	  "        lazy[index].min += change;",
	// 	  "    }",
	// 	  "    node combine(node& one, node& two) {",
	// 	  "        // combine recursive results and return",
	// 	  "        node ans;",
	// 	  "        ans.min = min(one.min, two.min);",
	// 	  "        return ans;",
	// 	  "    }",
	// 	  "    void push(lli index) {",
	// 	  "        if(mark[index]) {",
	// 	  "            lli left = index << 1, right = left | 1;",
	// 	  "            updateNode(left, lazy[index].min), updateNode(right, lazy[index].min);",
	// 	  "            mark[left] = mark[right] = true;",
	// 	  "            //   modify lazy			",
	// 	  "            lazy[index].min = 0;",
	// 	  "            mark[index] = false;",
	// 	  "        }",
	// 	  "    }",
	// 	  "    void update(lli index, lli start, lli end, lli l, lli r, lli change) {",
	// 	  "        if(l > end or r < start) return;",
	// 	  "        if(l <= start and r >= end) {",
	// 	  "            updateNode(index, change);",
	// 	  "            mark[index] = true;",
	// 	  "            return;",
	// 	  "        }",
	// 	  "        if(start == end) return;",
	// 	  "        push(index);",
	// 	  "        lli mid = (start + end) >> 1;",
	// 	  "        lli left = index << 1, right = left | 1;",
	// 	  "        update(left, start, mid, l, r, change), update(right, mid + 1, end, l, r, change);",
	// 	  "        tree[index] = combine(tree[left], tree[right]);",
	// 	  "    }",
	// 	  "    node query(lli index, lli start, lli end, lli l, lli r) {",
	// 	  "        if(l > end or r < start) {",
	// 	  "            return node();",
	// 	  "        }",
	// 	  "        if(l <= start and r >= end) {",
	// 	  "            return tree[index];",
	// 	  "        }",
	// 	  "        push(index);",
	// 	  "        lli mid = (start + end) >> 1;",
	// 	  "        lli left = index << 1, right = left | 1;",
	// 	  "        auto one = query(left, start, mid, l, r), two = query(right, mid + 1, end, l, r);",
	// 	  "        return combine(one, two);",
	// 	  "    }",
	// 	  "    void build(lli index, lli start, lli end) {",
	// 	  "        if(start == end) {",
	// 	  "            buildLeaf(index, start);",
	// 	  "            return;",
	// 	  "        }",
	// 	  "        lli mid = (start + end) >> 1;",
	// 	  "        lli left = index << 1, right = left | 1;",
	// 	  "        build(left, start, mid), build(right, mid + 1, end);",
	// 	  "        tree[index] = combine(tree[left], tree[right]);",
	// 	  "    }",
	// 	  "};  "
	// 	],
	// 	"description": "Segment Tree Range Minimum"
	//   },
	//   "Segment Tree Range Maximum": {
	// 	"prefix": "segTree-Max",
	// 	"body": [
	// 	  "class segTree {",
	// 	  "    public :",
	// 	  "    class node {",
	// 	  "        public :",
	// 	  "        lli max;",
	// 	  "        node() {",
	// 	  "            // initailize with neutral values",
	// 	  "            max = LLONG_MIN;",
	// 	  "        }",
	// 	  "        node(lli init) {  // initialize for lazy",
	// 	  "            max = init;",
	// 	  "        }",
	// 	  "    };",
	// 	  "    lli n;",
	// 	  "    vector<node> tree;",
	// 	  "    vector<lli> a;",
	// 	  "    vector<bool> mark;",
	// 	  "    vector<node> lazy;",
	// 	  "    segTree(vector<lli>& v) {",
	// 	  "        n = v.size();",
	// 	  "        a = v;",
	// 	  "        tree.resize(4*n + 1);",
	// 	  "        mark.resize(4*n + 1);",
	// 	  "        lazy.assign(4*n + 1, node(0));",
	// 	  "    }",
	// 	  "    node query(lli l, lli r) {",
	// 	  "        return query(1, 0, n - 1, l, r);",
	// 	  "    }",
	// 	  "    void update(lli l, lli r, lli change) {",
	// 	  "        update(1, 0, n - 1, l, r, change);",
	// 	  "    }",
	// 	  "    void build() {",
	// 	  "        build(1, 0, n - 1);",
	// 	  "    }",
	// 	  "    private :",
	// 	  "    void buildLeaf(lli index, lli start) {",
	// 	  "        // set leaf",
	// 	  "        tree[index].max = a[start];",
	// 	  "    }",
	// 	  "    void updateNode(lli index, lli change) {",
	// 	  "        // update node and lazy",
	// 	  "        tree[index].max += change;",
	// 	  "        lazy[index].max += change;",
	// 	  "    }",
	// 	  "    node combine(node& one, node& two) {",
	// 	  "        // combine recursive results and return",
	// 	  "        node ans;",
	// 	  "        ans.max = max(one.max, two.max);",
	// 	  "        return ans;",
	// 	  "    }",
	// 	  "    void push(lli index) {",
	// 	  "        if(mark[index]) {",
	// 	  "            lli left = index << 1, right = left | 1;",
	// 	  "            updateNode(left, lazy[index].max), updateNode(right, lazy[index].max);",
	// 	  "            mark[left] = mark[right] = true;",
	// 	  "            //   modify lazy       ",
	// 	  "            lazy[index].max = 0;",
	// 	  "            mark[index] = false;",
	// 	  "        }",
	// 	  "    }",
	// 	  "    void update(lli index, lli start, lli end, lli l, lli r, lli change) {",
	// 	  "        if(l > end or r < start) return;",
	// 	  "        if(l <= start and r >= end) {",
	// 	  "            updateNode(index, change);",
	// 	  "            mark[index] = true;",
	// 	  "            return;",
	// 	  "        }",
	// 	  "        if(start == end) return;",
	// 	  "        push(index);",
	// 	  "        lli mid = (start + end) >> 1;",
	// 	  "        lli left = index << 1, right = left | 1;",
	// 	  "        update(left, start, mid, l, r, change), update(right, mid + 1, end, l, r, change);",
	// 	  "        tree[index] = combine(tree[left], tree[right]);",
	// 	  "    }",
	// 	  "    node query(lli index, lli start, lli end, lli l, lli r) {",
	// 	  "        if(l > end or r < start) {",
	// 	  "            return node();",
	// 	  "        }",
	// 	  "        if(l <= start and r >= end) {",
	// 	  "            return tree[index];",
	// 	  "        }",
	// 	  "        push(index);",
	// 	  "        lli mid = (start + end) >> 1;",
	// 	  "        lli left = index << 1, right = left | 1;",
	// 	  "        auto one = query(left, start, mid, l, r), two = query(right, mid + 1, end, l, r);",
	// 	  "        return combine(one, two);",
	// 	  "    }",
	// 	  "    void build(lli index, lli start, lli end) {",
	// 	  "        if(start == end) {",
	// 	  "            buildLeaf(index, start);",
	// 	  "            return;",
	// 	  "        }",
	// 	  "        lli mid = (start + end) >> 1;",
	// 	  "        lli left = index << 1, right = left | 1;",
	// 	  "        build(left, start, mid), build(right, mid + 1, end);",
	// 	  "        tree[index] = combine(tree[left], tree[right]);",
	// 	  "    }",
	// 	  "};  "
	// 	],
	// 	"description": "Segment Tree Range Maximum"
	// },


	/****************************** Template For Mo's Algorithm - Square Root Decomposiiton *********************************/

	  "Mo Algorithm Package": {
		"prefix": "MoAlgo",
		"body": [
		  "class moNode {  // store left end, right end and query number for query",
		  "public :",
		  "    lli l, r, index;",
		  "    moNode(lli l, lli r, lli index) {",
		  "        this-> l = l;",
		  "        this-> r = r;",
		  "        this-> index = index;",
		  "    }",
		  "};",
		  "",
		  "class MoComparator {",
		  "    lli blockSize;",
		  "    public :",
		  "        MoComparator(lli blockSize) {",
		  "            this->blockSize = blockSize;",
		  "        }",
		  "        bool operator()(const moNode & one, const moNode & two) const {",
		  "            lli l = one.l/blockSize, r = two.l/blockSize;",
		  "            if(l != r) return l < r;",
		  "            else return one.r < two.r;",
		  "        }",
		  "};",
		  "",
		  "void solveMo(vector<moNode>& queries, vector<pll>& ans, vector<lli>& a) {",
		  "    auto add = [&](lli index) {",
		  "      ",
		  "    };",
		  "    auto remove = [&](lli index) {",
		  "       ",
		  "    };",
		  "    lli left = 0, right = 0;    ",
		  "    // for(auto q : queries) {",
		  "    //     lli l = q.l, r = q.r;",
		  "    //     while(left < l) {",
		  "    //         remove(left); left++;",
		  "    //     }",
		  "    //     while(left > l) {",
		  "    //         add(left - 1); left--;",
		  "    //     }",
		  "    //     while(right <= r) {",
		  "    //         add(right); right++;",
		  "    //     }",
		  "    //     while(right > r + 1) {",
		  "    //         remove(right - 1); right--;",
		  "    //     }",
		  "    // }",
		  "}"
		],
		"description": "Mo Algorithm Package"
	},


	// "Segment Tree Maximum And Minimum Gap": {
	// 	"prefix": "segTree-Gap",
	// 	"body": [
	// 		"class segTree {",
	// 		"    public :",
	// 		"    class node {",
	// 		"        public :",
	// 		"        lli l, r, xl, xr;",
	// 		"        lli max, min;",
	// 		"        lli xmax, xmin; ",
	// 		"        lli change; // for lazy",
	// 		"        node() {",
	// 		"            // initailize with neutral values",
	// 		"            l = r = xl = xr = change = -1;",
	// 		"            max = xmax -1e18;",
	// 		"            min = xmin = 1e18;",
	// 		"        }",
	// 		"        node(lli init) {  // initialize for lazy",
	// 		"            // min = init;",
	// 		"        }",
	// 		"    };",
	// 		"    lli n;",
	// 		"    vector<node> tree;",
	// 		"    vector<lli> a;",
	// 		"    vector<bool> mark;",
	// 		"    vector<node> lazy;",
	// 		"    segTree(vector<lli>& v) {",
	// 		"        n = v.size();",
	// 		"        a = v;",
	// 		"        tree.resize(4*n + 1);",
	// 		"        mark.resize(4*n + 1);",
	// 		"        lazy.resize(4*n + 1 /*Initialize Lazy*/);",
	// 		"    }",
	// 		"    node query(lli l, lli r) {",
	// 		"        return query(1, 0, n - 1, l, r);",
	// 		"    }",
	// 		"    void update(lli l, lli r, lli change) {",
	// 		"        update(1, 0, n - 1, l, r, change);",
	// 		"    }",
	// 		"    void build() {",
	// 		"        build(1, 0, n - 1);",
	// 		"    }",
	// 		"    private :",
	// 		"    void buildLeaf(lli index, lli start) {",
	// 		"        // set leaf",
	// 		"        tree[index].l = tree[index].r = start;",
	// 		"        tree[index].min = tree[index].xmin = 1e18; tree[index].max = tree[index].xmax = -1e18;",
	// 		"        tree[index].xl = tree[index].xr = -1;",
	// 		"    }",
	// 		"    void updateNode(lli index, lli change) {",
	// 		"        // update node and lazy",
	// 		"        if(change == -1) return;",
	// 		"        if(change) {",
	// 		"            tree[index].xl = tree[index].l;",
	// 		"            tree[index].xr = tree[index].r;",
	// 		"            tree[index].xmax = tree[index].max;",
	// 		"            tree[index].xmin = tree[index].min;",
	// 		"        }",
	// 		"        else {",
	// 		"            tree[index].xl = tree[index].xr = -1;",
	// 		"            tree[index].xmax = -1e18, tree[index].xmin = 1e18;",
	// 		"        }",
	// 		"    }",
	// 		"    node combine(node& one, node& two) {",
	// 		"        // combine recursive results and return",
	// 		"        node ans;",
	// 		"        if(one.l == -1 and two.l == -1) ans = one; ",
	// 		"        else if(one.l == -1) ans = two;",
	// 		"        else if(two.l == -1) ans = one;",
	// 		"        else {",
	// 		"            ans.l = one.l; ans.r = two.r;",
	// 		"            ans.max = a[ans.r] - a[ans.l];",
	// 		"            ans.min = min(a[two.l] - a[one.r], min(one.min, two.min));",
	// 		"        }",
	// 		"        if(one.xr == -1 and two.xl == -1) {",
	// 		"            ans.xl = ans.xr = -1;",
	// 		"            ans.xmax = -1e18; ans.xmin = 1e18;",
	// 		"        }",
	// 		"        else if(one.xr == -1) {",
	// 		"            ans.xl = two.xl, ans.xr = two.xr;",
	// 		"            ans.xmax = two.xmax; ans.xmin = two.xmin;",
	// 		"        }",
	// 		"        else if(two.xl == -1) {",
	// 		"            ans.xl = one.xl, ans.xr = one.xr;",
	// 		"            ans.xmax = one.xmax, ans.xmin = one.xmin;",
	// 		"        }",
	// 		"        else {",
	// 		"            ans.xl = one.xl; ans.xr = two.xr;",
	// 		"            ans.xmax = a[two.xr] - a[one.xl];",
	// 		"            ans.xmin = min(a[two.xl] - a[one.xr], min(two.xmin, one.xmin));",
	// 		"        }",
	// 		"        return ans;",
	// 		"    }",
	// 		"    void push(lli index) {",
	// 		"        if(mark[index]) {",
	// 		"            lli left = index << 1, right = left | 1;",
	// 		"            updateNode(left, lazy[index].change), updateNode(right, lazy[index].change);",
	// 		"            mark[left] = mark[right] = true;",
	// 		"            //   modify lazy	",
	// 		"            lazy[index].change = -1;		",
	// 		"            mark[index] = false;",
	// 		"        }",
	// 		"    }",
	// 		"    void update(lli index, lli start, lli end, lli l, lli r, lli change) {",
	// 		"        if(l > end or r < start) return;",
	// 		"        if(l <= start and r >= end) {",
	// 		"            updateNode(index, change);",
	// 		"            mark[index] = true;",
	// 		"            return;",
	// 		"        }",
	// 		"        if(start == end) return;",
	// 		"        push(index);",
	// 		"        lli mid = (start + end) >> 1;",
	// 		"        lli left = index << 1, right = left | 1;",
	// 		"        update(left, start, mid, l, r, change), update(right, mid + 1, end, l, r, change);",
	// 		"        tree[index] = combine(tree[left], tree[right]);",
	// 		"    }",
	// 		"    node query(lli index, lli start, lli end, lli l, lli r) {",
	// 		"        if(l > end or r < start) {",
	// 		"            return node();",
	// 		"        }",
	// 		"        if(l <= start and r >= end) {",
	// 		"            return tree[index];",
	// 		"        }",
	// 		"        push(index);",
	// 		"        lli mid = (start + end) >> 1;",
	// 		"        lli left = index << 1, right = left | 1;",
	// 		"        auto one = query(left, start, mid, l, r), two = query(right, mid + 1, end, l, r);",
	// 		"        return combine(one, two);",
	// 		"    }",
	// 		"    void build(lli index, lli start, lli end) {",
	// 		"        if(start == end) {",
	// 		"            buildLeaf(index, start);",
	// 		"            return;",
	// 		"        }",
	// 		"        lli mid = (start + end) >> 1;",
	// 		"        lli left = index << 1, right = left | 1;",
	// 		"        build(left, start, mid), build(right, mid + 1, end);",
	// 		"        tree[index] = combine(tree[left], tree[right]);",
	// 		"    }",
	// 		"}; "
	// 	],
	// 	"description": "Segment Tree Maximum And Minimum Gap"
	// },


	 /****************************** Modular Permutation And Combination Class *********************************/

	"PNC Class ": {
		"prefix": "PNC",
		"body": [
		  "class PNC {",
		  "    public :",
		  "        vector<unsigned lli> f;",
		  "        lli m;",
		  "        PNC(lli n, lli m = mod) {",
		  "            f.resize(n + 1);  this-> m = m; f[0] = 1;",
		  "            for(int i = 1; i <= n; i++) {",
		  "                f[i] = (i * f[i - 1]) % m;",
		  "            }",
		  "        }",
		  "        lli power(lli b, lli p, lli m = mod){",
		  "            lli res = 1;",
		  "            while(p > 0){",
		  "                if(p & 1)",
		  "                    res = ((res % m) * (b % m)) % m;",
		  "                b = ((b % m) * (b % m)) % m; p = p>>1;",
		  "            }",
		  "            return res;",
		  "        }",
		  "        lli modInverse(lli n, lli m = mod) { return power(n, m - 2, m); }",
		  "        lli factorial(lli n) { return f[n]; }",
		  "        lli nCr(lli n, lli r) { ",
		  "            if(r == 0) return 1;",
		  "            return (f[n] * modInverse(f[r], m) % m * modInverse(f[n - r], m) % m) % m;",
		  "        }",
		  "        lli nPr(lli n, lli r) {",
		  "            if(r == 0) return 1;",
		  "            return (f[n] * modInverse(f[n - r], m) % m) % m;",
		  "        }",
		  "};"
		],
		"description": "PNC Class ",
	},


	 /****************************** Template For Convex Hull Dynamic Programming Technique *********************************/


	"Convex Hull Trick DP": {
		"prefix": "DPConvex",
		"body": [
		  "class point {",
		  "    public :",
		  "        ld x, y;",
		  "        point(ld X = 0, ld Y = 0) {",
		  "            x = X, y = Y;",
		  "        }",
		  "        bool operator <(point& that) {",
		  "            if(x == that.x) return y < that.y;",
		  "            return x < that.x;",
		  "        }",
		  "};",
		  "",
		  "class line {",
		  "    public :",
		  "        ld m, c;",
		  "        line(ld m, ld c) : m(m), c(c) {}",
		  "        lli evaluate(ld x) {",
		  "            return m*x + c;",
		  "        }",
		  "};",
		  "",
		  "point intersection(line a, line b) {",
		  "    if(a.m == b.m) return point(INT_MAX, INT_MAX); // no unique solution",
		  "    point inter;",
		  "    inter.x = (ld)(b.c - a.c)/(ld)(a.m - b.m);",
		  "    inter.y = a.evaluate(inter.x);",
		  "    return inter;",
		  "}",
		  "",
		  "class DPConvex {",
		  "    public :",
		  "        vector<ld> p;",
		  "        deque<line> hull;",
		  "        void addLine(line a) {",
		  "            if(hull.size() == 0) {",
		  "                hull.push_back(a);",
		  "                return;",
		  "            }",
		  "            if(hull.size() == 1) {",
		  "                point in = intersection(a, hull.back());",
		  "                hull.push_back(a);",
		  "                p.push_back(in.x);",
		  "                return;",
		  "            }",
		  "            while(p.size()) {",
		  "                line r = hull.back();",
		  "                hull.pop_back();",
		  "                line s = hull.back();",
		  "                point in = intersection(a, s);",
		  "                if(in.x > p.back()) {    ",
		  "                    hull.push_back(r);",
		  "                    break;",
		  "                }",
		  "                else {",
		  "                    p.pop_back();",
		  "                }",
		  "            }",
		  "            p.push_back(intersection(a, hull.back()).x);",
		  "            hull.push_back(a);",
		  "        }",
		  "        ld findBest(ld x) {  // for max sort in ascending order, for min sort in descending order",
		  "            lli pos = lower_bound(p.begin(), p.end(), x) - p.begin();",
		  "            return hull[pos].evaluate(x);",
		  "        }",
		  "};"
		],
		"description": "Convex Hull Trick DP"
	},

	 
	/****************************** Algorithm To find Convex Hull Of Points *********************************/


	"Convex Hull for points": {
		"prefix": "ConvexHull",
		"body": [
		  "class point {",
		  "    public :",
		  "        lli x, y;",
		  "        point() {}",
		  "        point(lli X, lli Y) {",
		  "            x = X, y = Y;",
		  "        }",
		  "        bool operator <(const point& that) const{",
		  "            if(x == that.x) return y < that.y;",
		  "            else return x < that.x;",
		  "        }",
		  "        bool operator ==(point& that) {",
		  "            return (x == that.x and y == that.y); ",
		  "        }",
		  "};",
		  "",
		  "bool isCCW(point& a, point& b, point& c) {",
		  "    return a.x*(b.y - c.y) + b.x*(c.y - a.y) + c.x*(a.y - b.y) < 0;",
		  "}",
		  "",
		  "bool isCW(point& a, point& b, point& c) {",
		  "    return a.x*(b.y - c.y) + b.x*(c.y - a.y) + c.x*(a.y - b.y) > 0;",
		  "}",
		  "",
		  "bool isCollinear(point& a, point& b, point& c) {",
		  "    return a.x*(b.y - c.y) + b.x*(c.y - a.y) + c.x*(a.y - b.y) == 0;",
		  "}",
		  "",
		  "void convexHull(vector<point>& p) {",
		  "    lli n = p.size();",
		  "    sort(p.begin(), p.end());",
		  "    point p1 = p[0], p2 = p[n - 1];",
		  "    vector<point> up, down;",
		  "    up.push_back(p1); down.push_back(p1);",
		  "    for(int i = 1; i < n; i++) {",
		  "        if(i == n - 1 or !isCCW(p1, p[i], p2)) {",
		  "            while(up.size() >= 2 and isCCW(up[up.size() - 2], up[up.size() - 1], p[i])) {",
		  "                up.pop_back();",
		  "            }",
		  "            up.push_back(p[i]);",
		  "        }",
		  "        if(i == n - 1 or !isCW(p1, p[i], p2)) {",
		  "            while(down.size() >= 2 and isCW(down[down.size() - 2], down[down.size() - 1], p[i])) {",
		  "                down.pop_back();",
		  "            }",
		  "            down.push_back(p[i]);",
		  "        }        ",
		  "    }",
		  "    p.clear();",
		  "    for(auto e : up) p.push_back(e);",
		  "    for(auto e : down) p.push_back(e);",
		  "    sort(p.begin(), p.end());",
		  "    p.resize(unique(p.begin(), p.end()) - p.begin());",
		  "}"
		],
		"description": "Convex Hull for points"
	},


	/****************************** Segment Tree General Template *********************************/
	
	
	"Segment Tree General Template": {
		"prefix": "segTree",
		"body": [
		  "class segTreeNode {",
		  "public :",
		  "    /* Class Data Members */",
		  "",
		  "    /* This node is a class implementing the following methods: ",
		  "    * constructor: identity element of monoid (you should have the neutral values)",
		  "    * constructor: element created by combining 2 elements",
		  "    */",
		  "    segTreeNode() {}",
		  "    segTreeNode(const segTreeNode& one, const segTreeNode& two) {}  ",
		  "};",
		  "",
		  "class Function {",
		  "public :",
		  "    /* Function Data Members */",
		  "",
		  "    /* A Function is a class implementing the following methods: ",
		  "    * constructor: identity function",
		  "    * constructor : to construct arbitrary function",
		  "    * constructor: function composition (f1.f2)",
		  "    * whether this function is the identity function",
		  "    * function definition (action on segTreeNode)",
		  "    */",
		  "    Function() {}  ",
		  "    Function(/**/) {}",
		  "    Function(const Function& f1, const Function& f2) {}  ",
		  "    bool is_identity() const {}  ",
		  "    segTreeNode operator()(const segTreeNode& node) {}  ",
		  "",
		  "};",
		  "",
		  "template<class M, class F>",
		  "class SegTree {",
		  "// M is a node",
		  "// F is a function",
		  "// remember to set leaf nodes from calling function",
		  "public:",
		  "    typedef M value_type;",
		  "    typedef F func_type;",
		  "",
		  "    static void identity_check() {",
		  "        if(!F().is_identity()) {",
		  "            cout << \"Default Constructor is not identity !!!\" << endl;",
		  "        }",
		  "    }",
		  "",
		  "private:",
		  "    lli n;",
		  "    vector<M> values;  // the segment tree",
		  "    vector<F> pends;   // stores pending updates for lazy propogation",
		  "",
		  "    lli segtree_size(lli n) {",
		  "        n -= 1;",
		  "        n |= n >> 1;",
		  "        n |= n >> 2;",
		  "        n |= n >> 4;",
		  "        n |= n >> 8;",
		  "        n |= n >> 16;",
		  "        return 2 * n + 1;",
		  "    }",
		  "",
		  "public:",
		  "    explicit SegTree(lli N):",
		  "        n(N), values(segtree_size(n)), pends(values.size()) {identity_check();}  // creates empty segment tree",
		  "    explicit SegTree(lli N, const M& x):",
		  "        n(N), values(segtree_size(n)), pends(values.size()) {identity_check(); assign(x);}  // segment tree with fixed leaf values ",
		  "    explicit SegTree(std::vector<M>& v):",
		  "        n(v.size()), values(segtree_size(v.size())), pends(values.size()) {identity_check(); assign(v);}",
		  "",
		  "private:",
		  "    // build function with vector of leaves ",
		  "    void assign_values(lli root, lli first, lli last, vector<M> &a) {",
		  "        // root has the node number, first and last have the array indices.",
		  "        if(first == last) {",
		  "            values[root] = a[first];",
		  "        }",
		  "        else {",
		  "            lli left = 2 * root + 1;",
		  "            lli mid = (first + last) / 2;",
		  "            assign_values(left, first, mid, a);",
		  "            assign_values(left + 1, mid + 1, last, a);",
		  "            values[root] = M(values[left], values[left + 1]);",
		  "        }",
		  "    }",
		  "",
		  "    // build function with every leaf assigned x",
		  "    void assign_values(lli root, lli first, lli last, M& x) {",
		  "        // root has the node number, first and last have the array indices.",
		  "        if(first == last) {",
		  "            values[root] = x;",
		  "        }",
		  "        else {",
		  "            lli left = 2 * root + 1;",
		  "            lli mid = (first + last) / 2;",
		  "            assign_values(left, first, mid, x);",
		  "            assign_values(left+1, mid+1, last, x);",
		  "            values[root] = M(values[left], values[left+1]);",
		  "        }",
		  "    }",
		  "",
		  "public:",
		  "    // assign every leaf x",
		  "    void assign(M& x) {",
		  "        pends.assign(values.size(), F());",
		  "        assign_values(0, 0, n - 1, x);",
		  "    }",
		  "",
		  "    // assign every leaf corresponding vector entry",
		  "    void assign(vector<M>& v) {",
		  "        if(v.size() < n) {",
		  "            std::exit(3);",
		  "        }",
		  "        assign_values(0, 0, n - 1, v);",
		  "    }",
		  "",
		  "private:",
		  "    // lazy propagation",
		  "    void propagate(lli root, lli first, lli last) {",
		  "        if(!pends[root].is_identity()) {",
		  "            values[root] = pends[root](values[root]);",
		  "            if(first != last)",
		  "            {",
		  "                lli left = 2 * root + 1;",
		  "                pends[left] = F(pends[root], pends[left]);",
		  "                pends[left + 1] = F(pends[root], pends[left + 1]);",
		  "            }",
		  "            pends[root] = F();",
		  "        }",
		  "    }",
		  "    // query from range l to r (zero indexing)",
		  "    M query(lli root, lli first, lli last, lli l, lli r) {",
		  "        if(l > last or r < first) {",
		  "            return M();",
		  "        }",
		  "        propagate(root, first, last);",
		  "        if(l <= first and last <= r) {",
		  "            return values[root];",
		  "        }",
		  "        else {",
		  "            lli left = 2 * root + 1;",
		  "            lli mid = (first + last) / 2;",
		  "            return M(query(left, first, mid, l, r), query(left + 1, mid + 1, last, l, r));",
		  "        }",
		  "    }",
		  "",
		  "public:",
		  "    // query from range l to r (zero indexing)",
		  "    M query(lli l, lli r) {",
		  "        return query(0, 0, n - 1, l, r);",
		  "    }",
		  "",
		  "private:",
		  "    // update from range l to r by giving update function (zero indexing)",
		  "    void update(lli root, lli first, lli last, lli l, lli r, const F& f) {",
		  "        if(l > last or r < first) {",
		  "            propagate(root, first, last);",
		  "        }",
		  "        else if(l <= first and last <= r) {",
		  "            pends[root] = F(f, pends[root]);",
		  "            propagate(root, first, last);",
		  "        }",
		  "        else {",
		  "            propagate(root, first, last);",
		  "            lli left = 2 * root + 1;",
		  "            lli mid = (first + last) / 2;",
		  "            update(left, first, mid, l, r, f);",
		  "            update(left + 1, mid + 1, last, l, r, f);",
		  "            values[root] = M(values[left], values[left + 1]);",
		  "        }",
		  "    }",
		  "",
		  "public:",
		  "    // update from range l to r by giving update function (zero indexing)",
		  "    void update(lli l, lli r, const F& f) {",
		  "        update(0, 0, n - 1, l, r, f);",
		  "    }",
		  "};"
		],
		"description": "Segment Tree General Template"
	},
	
	
	/****************************** Segment Tree For Basic Operations For Min, Max And Sum *********************************/
	
	
	"Segment Tree With Basic Min, Max And Sum": {
		"prefix": "segTree-Basic",
		"body": [
		  "class segTreeNode {",
		  "public :",
		  "    /* Class Data Members */",
		  "    lli mx, mn, l, r, diff, sum;",
		  "    /* This node is a class implementing the following methods: ",
		  "    * constructor: identity element of monoid (you should have the neutral values)",
		  "    * constructor: element created by combining 2 elements",
		  "    */",
		  "    segTreeNode() {",
		  "        mx = -1e18, mn = 1e18;",
		  "        diff = 0ll;",
		  "        l = -1, r = -1; sum = 0ll;",
		  "    }",
		  "    segTreeNode(const segTreeNode& one, const segTreeNode& two) {",
		  "        mx = max(one.mx, two.mx);",
		  "        mn = min(one.mn, two.mn);",
		  "        l = one.l, r = two.r;",
		  "        if(l == -1) l = two.l;",
		  "        if(r == -1) r = one.r;",
		  "        diff = one.diff + two.diff;",
		  "        sum = one.sum + two.sum;",
		  "    }  ",
		  "};",
		  "",
		  "class Function {",
		  "public :",
		  "    /* Function Data Members */",
		  "    lli a, b;",
		  "    /* A Function is a class implementing the following methods: ",
		  "    * constructor: identity function",
		  "    * constructor : to construct arbitrary function",
		  "    * constructor: function composition (f1.f2)",
		  "    * whether this function is the identity function",
		  "    * function definition (action on segTreeNode)",
		  "    */",
		  "    Function() {",
		  "        a = 1, b = 0;",
		  "    }",
		  "    Function(lli a, lli b) : a(a), b(b) {",
		  "",
		  "    }",
		  "    Function(const Function& f1, const Function& f2) {",
		  "        a = f1.a * f2.a;",
		  "        b = f1.a * f2.b + f1.b;",
		  "    }  ",
		  "    bool is_identity() const {",
		  "        return a == 1 and b == 0;",
		  "    }  ",
		  "    segTreeNode operator()(const segTreeNode& node) {",
		  "        segTreeNode ans = node;",
		  "        ans.mn = a * node.mn + b;",
		  "        ans.mx = a * node.mx + b;",
		  "        ans.sum = node.diff * b + a * node.sum;",
		  "        return ans;",
		  "    }  ",
		  "",
		  "};",
		  "",
		  "template<class M, class F>",
		  "class SegTree {",
		  "// M is a node",
		  "// F is a function",
		  "// remember to set leaf nodes from calling function with diff = 1",
		  "public:",
		  "    typedef M value_type;",
		  "    typedef F func_type;",
		  "",
		  "    static void identity_check() {",
		  "        if(!F().is_identity()) {",
		  "            cout << \"Default Constructor is not identity !!!\" << endl;",
		  "        }",
		  "    }",
		  "",
		  "private:",
		  "    lli n;",
		  "    vector<M> values;  // the segment tree",
		  "    vector<F> pends;   // stores pending updates for lazy propogation",
		  "",
		  "    lli segtree_size(lli n) {",
		  "        n -= 1;",
		  "        n |= n >> 1;",
		  "        n |= n >> 2;",
		  "        n |= n >> 4;",
		  "        n |= n >> 8;",
		  "        n |= n >> 16;",
		  "        return 2 * n + 1;",
		  "    }",
		  "",
		  "public:",
		  "    explicit SegTree(lli N):",
		  "        n(N), values(segtree_size(n)), pends(values.size()) {identity_check();}  // creates empty segment tree",
		  "    explicit SegTree(lli N, const M& x):",
		  "        n(N), values(segtree_size(n)), pends(values.size()) {identity_check(); assign(x);}  // segment tree with fixed leaf values ",
		  "    explicit SegTree(std::vector<M>& v):",
		  "        n(v.size()), values(segtree_size(v.size())), pends(values.size()) {identity_check(); assign(v);}",
		  "",
		  "private:",
		  "    // build function with vector of leaves ",
		  "    void assign_values(lli root, lli first, lli last, vector<M> &a) {",
		  "        // root has the node number, first and last have the array indices.",
		  "        if(first == last) {",
		  "            values[root] = a[first];",
		  "        }",
		  "        else {",
		  "            lli left = 2 * root + 1;",
		  "            lli mid = (first + last) / 2;",
		  "            assign_values(left, first, mid, a);",
		  "            assign_values(left + 1, mid + 1, last, a);",
		  "            values[root] = M(values[left], values[left + 1]);",
		  "        }",
		  "    }",
		  "",
		  "    // build function with every leaf assigned x",
		  "    void assign_values(lli root, lli first, lli last, M& x) {",
		  "        // root has the node number, first and last have the array indices.",
		  "        if(first == last) {",
		  "            values[root] = x;",
		  "        }",
		  "        else {",
		  "            lli left = 2 * root + 1;",
		  "            lli mid = (first + last) / 2;",
		  "            assign_values(left, first, mid, x);",
		  "            assign_values(left + 1, mid + 1, last, x);",
		  "            values[root] = M(values[left], values[left + 1]);",
		  "        }",
		  "    }",
		  "",
		  "public:",
		  "    // assign every leaf x",
		  "    void assign(M& x) {",
		  "        pends.assign(values.size(), F());",
		  "        assign_values(0, 0, n - 1, x);",
		  "    }",
		  "",
		  "    // assign every leaf corresponding vector entry",
		  "    void assign(vector<M>& v) {",
		  "        if(v.size() < n) {",
		  "            std::exit(3);",
		  "        }",
		  "        assign_values(0, 0, n - 1, v);",
		  "    }",
		  "",
		  "private:",
		  "    // lazy propagation",
		  "    void propagate(lli root, lli first, lli last) {",
		  "        if(!pends[root].is_identity()) {",
		  "            values[root] = pends[root](values[root]);",
		  "            if(first != last)",
		  "            {",
		  "                lli left = 2 * root + 1;",
		  "                pends[left] = F(pends[root], pends[left]);",
		  "                pends[left + 1] = F(pends[root], pends[left + 1]);",
		  "            }",
		  "            pends[root] = F();",
		  "        }",
		  "    }",
		  "    // query from range l to r (zero indexing)",
		  "    M query(lli root, lli first, lli last, lli l, lli r) {",
		  "        if(l > last or r < first) {",
		  "            return M();",
		  "        }",
		  "        propagate(root, first, last);",
		  "        if(l <= first and last <= r) {",
		  "            return values[root];",
		  "        }",
		  "        else {",
		  "            lli left = 2 * root + 1;",
		  "            lli mid = (first + last) / 2;",
		  "            return M(query(left, first, mid, l, r), query(left + 1, mid + 1, last, l, r));",
		  "        }",
		  "    }",
		  "",
		  "public:",
		  "    // query from range l to r (zero indexing)",
		  "    M query(lli l, lli r) {",
		  "        return query(0, 0, n - 1, l, r);",
		  "    }",
		  "",
		  "private:",
		  "    // update from range l to r by giving update function (zero indexing)",
		  "    void update(lli root, lli first, lli last, lli l, lli r, const F& f) {",
		  "        if(l > last or r < first) {",
		  "            propagate(root, first, last);",
		  "        }",
		  "        else if(l <= first and last <= r) {",
		  "            pends[root] = F(f, pends[root]);",
		  "            propagate(root, first, last);",
		  "        }",
		  "        else {",
		  "            propagate(root, first, last);",
		  "            lli left = 2 * root + 1;",
		  "            lli mid = (first + last) / 2;",
		  "            update(left, first, mid, l, r, f);",
		  "            update(left + 1, mid + 1, last, l, r, f);",
		  "            values[root] = M(values[left], values[left + 1]);",
		  "        }",
		  "    }",
		  "",
		  "public:",
		  "    // update from range l to r by giving update function (zero indexing)",
		  "    void update(lli l, lli r, const F& f) {",
		  "        update(0, 0, n - 1, l, r, f);",
		  "    }",
		  "};"
		],
		"description": "Segment Tree With Basic Min, Max And Sum"
	},



	/****************************** Trie Data Structure *********************************/

	
	"Trie Data Structure": {
		"prefix": "Trie",
		"body": [
		  "class trieNode {",
		  "    public :",
		  "        char ch;            // character at the particular node ",
		  "        int num;            // number of strings that have the substring till the current node as a prefix",
		  "        bool valid;                     // true if some string ends at this node ",
		  "        vector<trieNode*> children;",
		  "        trieNode(char ch, int alpha) : ch(ch) {",
		  "            children.assign(alpha, NULL);  // number of children depends on the number of letters in the alphabet",
		  "            num = 1;",
		  "            valid = false;",
		  "        }",
		  "};",
		  "",
		  "class Trie {",
		  "    private :",
		  "        bool add(trieNode* root, int pos, const string& s) {      // adds a string to the Trie",
		  "            if(root->children[s[pos] - base] == NULL) {",
		  "                root->children[s[pos] - base] = new trieNode(s[pos], alpha);",
		  "                if(pos == s.length() - 1) {",
		  "                    root->children[s[pos] - base]->valid = true;",
		  "                }",
		  "                else {",
		  "                    return add(root->children[s[pos] - base], pos + 1, s);",
		  "                }",
		  "            }",
		  "            else {",
		  "                root->children[s[pos] - base]->num++;",
		  "                bool flag = root->children[s[pos] - base]->valid;",
		  "                if(pos == s.length() - 1) {",
		  "                    root->children[s[pos] - base]->valid = true;",
		  "                    return true;",
		  "                }",
		  "                else {",
		  "                    bool ans = add(root->children[s[pos] - base], pos + 1, s);",
		  "                    return flag or ans;",
		  "                }",
		  "            }",
		  "            return false;",
		  "        }",
		  "        int searchPrefix(trieNode* root, int pos, const string& s) {  // searches the number of occurence of the current prefix",
		  "            if(root->children[s[pos] - base] == NULL) {",
		  "                return 0;",
		  "            }",
		  "            if(pos == s.length() - 1) {",
		  "                return root->children[s[pos] - base]->num;",
		  "            }",
		  "            return searchPrefix(root->children[s[pos] - base], pos + 1, s);",
		  "        }",
		  "        bool search(trieNode* root, int pos, const string& s) {    // checks if the given string is in the Trie",
		  "            if(root->children[s[pos] - base] == NULL) {",
		  "                return false;",
		  "            }",
		  "            if(pos == s.length() - 1) {",
		  "                return root->children[s[pos] - base]->valid;",
		  "            }",
		  "            return search(root->children[s[pos] - base], pos + 1, s);",
		  "        }",
		  "        void remove(trieNode* root, int pos, const string& s) {  // removes the given string from the Trie",
		  "            if(root->children[s[pos] - base] == NULL) {",
		  "                return;",
		  "            }",
		  "            root->children[s[pos] - base]->num--;",
		  "            if(pos == s.length() - 1) {",
		  "                root->children[s[pos] - base]->valid = false;",
		  "            }",
		  "            remove(root->children[s[pos] - base], pos + 1, s);",
		  "        }",
		  "    public :",
		  "        trieNode* root;",
		  "        char base;          // the first character in the trie alphabet",
		  "        int alpha;          // size of the input alphabet",
		  "        Trie(char base = 'a', int alpha = 26) : base(base), alpha(alpha) {",
		  "            root = new trieNode('*', alpha);",
		  "        }",
		  "        bool add(const string& s) {",
		  "            return add(root, 0, s);",
		  "        }",
		  "        bool search(const string& s) {",
		  "            return search(root, 0, s);",
		  "        }",
		  "        int searchPrefix(const string& s) {",
		  "            return searchPrefix(root, 0, s);",
		  "        }   ",
		  "        void remove(const string& s) {",
		  "            remove(root, 0, s);",
		  "        }",
		  "};"
		],
		"description": "Trie Data Structure"
	},


	/****************************** KMP Algorithm *********************************/

	"KMP Algorithm": {
		"prefix": "KMP",
		"body": [
		  "vector<lli> KMP(string & txt, string & pat){ // find all occurences of matching of pattern in given text",
		  "    lli n = txt.length();",
		  "    lli m = pat.length();",
		  "    vector<lli> v;",
		  "    if(m > n){",
		  "        return v;",
		  "    }",
		  "    vector<lli> sp(m);",
		  "    sp[0] = 0;",
		  "    int i = 1;",
		  "    lli len = 0;",
		  "    while(i < m){",
		  "        if(pat[i] == pat[len]){  // or pat[i] == pat[len]",
		  "            len++;",
		  "            sp[i] = len;",
		  "            i++;",
		  "        }",
		  "        else {",
		  "            if(len == 0){",
		  "                sp[i] = 0;",
		  "                i++;",
		  "            }",
		  "            else {",
		  "                len = sp[len - 1]; // we try to match from the previous character",
		  "            }",
		  "        }",
		  "    }",
		  "    int j = 0;",
		  "    i = 0;",
		  "    while(i < n){",
		  "        if(txt[i] == pat[j]){",
		  "            j++;",
		  "            i++;",
		  "        }",
		  "        if(j == m){",
		  "            v.push_back(i - j);  // match found",
		  "            j = sp[j - 1];",
		  "        }",
		  "        else if(i < n && txt[i] != pat[j]){",
		  "            if(j != 0){",
		  "                j = sp[j - 1];",
		  "            }",
		  "            else {",
		  "                i++;",
		  "            }",
		  "        }",
		  "    }",
		  "    return v;",
		  "}"
		],
		"description": "KMP Algorithm"
	  }

}